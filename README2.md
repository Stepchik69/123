### **1. Сортировка выбором (Selection Sort)**

**Определение:** Алгоритм, который последовательно находит минимальный элемент в неотсортированной части массива и перемещает его в начало.

**Как работает:**
- Проходит по массиву от начала до конца
- Для каждой позиции находит минимальный элемент в оставшейся части
- Обменивает найденный минимальный элемент с текущим
- Постепенно формирует отсортированную часть в начале массива

**Сложность:** O(n²)  
**Причина:** Двойной вложенный цикл приводит к n*(n-1)/2 сравнениям

**Пример:**  
[23, 56, 21, 41, 12] → [12, 21, 23, 41, 56]

---

### **2. Сортировка пузырьком (Bubble Sort)**

**Определение:** Простой алгоритм, многократно сравнивающий и обменивающий соседние элементы.

**Как работает:**
- Последовательно сравнивает соседние элементы
- Если порядок неправильный - меняет их местами
- На каждом проходе "всплывает" наибольший элемент
- Процесс повторяется до полной сортировки

**Сложность:**
- Худший случай: O(n²)
- Лучший случай: O(n)

**Причина:** В худшем случае требуется n проходов по n элементам

**Пример:**  
[64, 34, 25, 12, 22, 11, 90] → [11, 12, 22, 25, 34, 64, 90]

---

### **3. Сортировка вставками (Insertion Sort)**

**Определение:** Алгоритм, который строит отсортированную часть массива, последовательно вставляя элементы на правильные позиции.

**Как работает:**
- Начинает со второго элемента
- Каждый новый элемент сравнивает с уже отсортированными
- Находит правильную позицию и вставляет элемент
- Сдвигает остальные элементы при необходимости

**Сложность:**
- Худший случай: O(n²)
- Лучший случай: O(n)

**Причина:** В худшем случае каждый элемент сравнивается со всеми предыдущими

**Пример:**  
[15, 8, 42, 4, 23, 16] → [4, 8, 15, 16, 23, 42]

---

### **4. Сортировка слиянием (Merge Sort)**

**Определение:** Алгоритм "разделяй и властвуй", рекурсивно делящий массив и объединяющий отсортированные части.

**Как работает:**
- Рекурсивно делит массив пополам
- Сортирует каждую половину отдельно
- Объединяет отсортированные половины в правильном порядке
- Использует дополнительную память для слияния

**Сложность:** O(n log n)  
**Причина:** Массив делится log n раз, на каждом уровне обрабатываются n элементов

**Пример:**  
[38, 27, 43, 3, 9, 82, 10] → [3, 9, 10, 27, 38, 43, 82]

---

### **5. Сортировка Шелла (Shell Sort)**

**Определение:** Улучшенная версия сортировки вставками, сравнивающая элементы на определённом расстоянии.

**Как работает:**
- Использует уменьшающийся шаг для сравнения элементов
- Сортирует элементы на большом расстоянии друг от друга
- Постепенно уменьшает шаг до 1
- На последнем этапе работает как обычная сортировка вставками

**Сложность:**
- Средний случай: O(n log n)
- Худший случай: O(n²)

**Причина:** Эффективность зависит от выбора последовательности шагов

**Пример:**  
[23, 12, 1, 8, 34, 54, 2, 3] → [1, 2, 3, 8, 12, 23, 34, 54]

---

### **6. Быстрая сортировка (Quick Sort)**

**Определение:** Эффективный алгоритм, использующий стратегию "разделяй и властвуй" с опорным элементом.

**Как работает:**
- Выбирает опорный элемент
- Разделяет массив на элементы меньше и больше опорного
- Рекурсивно применяет алгоритм к обеим частям
- Объединяет результаты без дополнительной памяти

**Сложность:**
- Средний случай: O(n log n)
- Худший случай: O(n²)

**Причина:** Эффективность зависит от выбора опорного элемента

**Пример:**  
[24, 15, 38, 2, 19, 41, 8] → [2, 8, 15, 19, 24, 38, 41]

---

### **7. Пирамидальная сортировка (Heap Sort)**

**Определение:** Алгоритм, использующий структуру данных "бинарная куча" для сортировки.

**Как работает:**
- Преобразует массив в бинарную max-кучу
- Последовательно извлекает максимальный элемент
- Перемещает его в конец массива
- Восстанавливает свойства кучи после каждого извлечения

**Сложность:** O(n log n)  
**Причина:** Построение кучи - O(n), каждое извлечение - O(log n)

**Пример:**  
[4, 10, 3, 5, 1] → [1, 3, 4, 5, 10]
